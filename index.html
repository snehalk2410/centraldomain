<!DOCTYPE html>
<html>
  <head>
    <title>W3.CSS Template</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="https://www.w3schools.com/w3css/4/w3.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Montserrat">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
    <style>
    .w3-sidebar a {font-family: "Roboto", sans-serif}
    body,h1,h2,h3,h4,h5,h6,.w3-wide {font-family: "Montserrat", sans-serif;}
    </style>  
  <!-- OneTrust Cookies Consent Notice start for testinovation-cdp.vercel.app -->
 
<script src="https://cdn.cookielaw.org/scripttemplates/otSDKStub.js"  type="text/javascript" charset="UTF-8" data-domain-script="0195138c-cdc8-738c-907d-131dad8db9ba-test" ></script>
<script type="text/javascript">
function OptanonWrapper() { }
</script>
<!-- OneTrust Cookies Consent Notice end for testinovation-cdp.vercel.app -->
    
 <!--  <script type="text/javascript" src="https://web-analytics-dot-uxlwqzc-cdip-sandbox-test.uc.r.appspot.com/ajhnjdnskjnvcksbc/analytics"> 
</script> -->

   <script type="text/javascript">

function generateUserID() {
  try {
    let randomPart = crypto.randomUUID();
    var timestampPart = Math.floor(Date.now() / 1000).toString(16); // Current timestamp in seconds (to ensure uniqueness)
    return randomPart + '.' + timestampPart; // Combine random part and timestamp for a unique ID  
  } catch (error) {
    console.log("Error : ", error);
  }
}
function getQueryParam(param) {
  try {
    let urlParams = new URLSearchParams(window.location.search);
    return urlParams.get(param);
  } catch (error) {
    console.log("Error : ", error);
  }
}

let rdUserID = getCookie('rdUserId');
let userID = getCookie('userID');
let sessionID = getCookie('sessionID');
let consentFlag = localStorage.getItem("consentObject");
let consentObj = {};
let userObj = {};
let pageObj = {};
if (consentFlag) {
  consentObj = JSON.parse(localStorage.getItem("consentObject"))
}
let userObjFlag = localStorage.getItem("userObject");
if (userObjFlag) {
  userObj = JSON.parse(localStorage.getItem("userObject"))
}
let pageInfoFlag = localStorage.getItem("pageObject");
if (pageInfoFlag) {
  pageObj = JSON.parse(localStorage.getItem("pageObject"))
}
let consentTrack = getCookie('consentTrack');

// Function to get a cookie by name
function getCookie(name) {
  try {
    const cookies = document.cookie.split(';');
    for (let cookie of cookies) {
      const [key, value] = cookie.split('=');
      if (key.trim() === name.trim()) {
        return decodeURIComponent(value);
        // return value;
      }
    }
    return null; // Return null if the cookie is not found
  } catch (error) {
    console.log("Error : ", error);
  }
}

// Function to extract Google Analytics client ID from the _ga cookie
function getGAClientId() {
  try {
    let gaCookie = getCookie('_ga'); // Get the _ga cookie value
    if (gaCookie) {
      // The _ga cookie value looks like: GA1.2.121232456.3445434334
      let gaParts = gaCookie.split('.'); // Split it into parts
      if (gaParts.length === 4) {
        return gaParts[2] + '.' + gaParts[3]; // Return the client ID (e.g., 121232456.3445434334)
      }
    }
    return null; // Return null if the cookie is not found or can't be parsed
  } catch (error) {
    console.log("Error : ", error);

  }
}

// Function to set a session cookie with security measures
function setSessionCookie(name, value) {
  try {
    const expires = "expires=Session"; // Session cookie expires when the browser is closed
    const secure = window.location.protocol === 'https:' ? "Secure" : ""; // Only secure if HTTPS
    const sameSite = "SameSite=Lax"; // Allow cross-origin requests to a certain extent
    let domain = window.location.hostname.split('.').slice(-2).join('.'); // Get root domain
    //domain=." + domain + ";
    document.cookie = name + "=" + value + ";" + expires + ";path=/;" + secure + ";" + sameSite;
  } catch (error) {
    console.log("Error : ", error);

  }
}
// Function to check if the session should reset at midnight
function checkMidnightSessionReset() {
  try {
    const currentTime = new Date(); // Get the current date and time
    const midnight = new Date(currentTime); // Create a new Date object for midnight today
    midnight.setHours(0, 0, 0, 0); // Set time to midnight (00:00:00)
    const nextMidnight = new Date(midnight.getTime() + 24 * 60 * 60 * 1000); // Calculate the next midnight

    if (currentTime >= nextMidnight) {
      // If the current time is after next midnight, reset the sessionID
      setSessionCookie('sessionID', ''); // Clear the session cookie
    }
  } catch (error) {
    console.log("Error : ", error);

  }
}

// Function to track user inactivity and reset the session if the user is inactive for more than 30 minutes
function trackInactivity() {
  try {
    let inactivityTimeout;
    const resetInactivityTimer = () => {
      clearTimeout(inactivityTimeout); // Clear any previous inactivity timeout
      inactivityTimeout = setTimeout(() => {
        setSessionCookie('sessionID', ''); // Reset session after inactivity
        console.log("Session expired due to inactivity.");
      }, 30 * 60 * 1000); // Set timeout for 30 minutes of inactivity
    };

    // Event listeners for mouse movement, keypress, or scroll reset the inactivity timer
    window.addEventListener('mousemove', resetInactivityTimer);
    window.addEventListener('keydown', resetInactivityTimer);
    window.addEventListener('scroll', resetInactivityTimer);
    resetInactivityTimer(); // Initialize the inactivity timer
  } catch (error) {
    console.log("Error : ", error);

  }
}

// Function to set a persistent cookie with security measures
function setPersistentCookie(name, value, days = 365) {
  try {
    const date = new Date();
    date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000)); // Calculate the expiration date
    const expires = "expires=" + date.toUTCString(); // Convert to UTC string format
    const secure = window.location.protocol === 'https:' ? "Secure" : ""; // Only secure if HTTPS
    const sameSite = "SameSite=Lax"; // Allow cross-origin requests to a certain extent -- Lax
    const domain = window.location.hostname.split('.').slice(-2).join('.'); // Get root domain     // "domain=.vercel.app"; // Set the highest-level domain
    console.log(" highest-level domain ", domain);
    //  const cookieString = `${name}=${value}; ${expires}; path=/; ${secure}; ${sameSite}`;
    //  console.log("Setting cookie: ", cookieString);
    //  document.cookie = cookieString;

    document.cookie = name + "=" + value + ";" + expires + ";path=/;" + secure + ";" + sameSite;
  } catch (error) {
    console.log("Error : ", error);

  }
}

// Function to extract UTM parameters (such as source, medium, campaign) from the URL query string
function getUTMParams() {
  try {
     const params = {};  // Object to store UTM parameters
    const urlParams = new URLSearchParams(window.location.search);  // Parse the query string of the URL
    console.log(" urlParams ", urlParams);
    // List of UTM parameters to check in the URL
    ['utm_source', 'utm_medium', 'utm_campaign', 'utm_term', 'utm_content'].forEach(param => {
      const value = urlParams.get(param);  // Get the value of each UTM parameter
      if (value) {  // If the parameter exists in the URL
        params[param] = value;  // Store the value in the params object
        setPersistentCookie(param, value);  // Set the UTM parameter as a persistent cookie
      }
    });
    return params;  // Return the UTM parameters object
  } catch (error) {
    console.log("Error : ", error);

  }
}

// Function to detect the device type (mobile or desktop)
function getDeviceType() {
  try {
    // Use a regular expression to check if the user agent matches a mobile device
    // return /Mobi|Android|iPhone|iPad|iPod|iOS/i.test(navigator.userAgent) ? 'mobile' : 'desktop';
    const userAgent = navigator.userAgent.toLowerCase();
    const screenWidth = window.innerWidth;
    const screenHeight = window.innerHeight;
    var deviceType = "desktop";
    if (/mobile|android|iphone|ipod/i.test(userAgent)) {
      deviceType = "mobile";
    } else if (/tablet|ipad/i.test(userAgent) || (screenWidth > 600 && screenWidth < 1024)) {
      deviceType = "tablet";
    }
    return { deviceType: deviceType, screenWidth: screenWidth, screenHeight: screenHeight }
  } catch (error) {
    console.log("Error : ", error);

  }
}

// Function to detect the operating system of the user
function getOS() {
  try {
    const userAgent = navigator.userAgent;
    const platform = navigator.platform || navigator.userAgentData?.platform || "Unknown";
    const osMap = [
      { name: "Windows", regex: /Win/i, versionRegex: /Windows NT (\d+\.\d+)/ },
      { name: "MacOS", regex: /Mac/i, versionRegex: /Mac OS X (\d+[_\.\d]+)/ },
      { name: "Linux", regex: /Linux/i, versionRegex: null },  // Linux versions are hard to detect reliably
      { name: "Android", regex: /Android/i, versionRegex: /Android (\d+\.\d+)/ },
      { name: "iOS", regex: /iPhone|iPad|iPod/i, versionRegex: /OS (\d+[_\.\d]+)/ },
      { name: "ChromeOS", regex: /CrOS/i, versionRegex: /CrOS [^\s]+ (\d+\.\d+\.\d+)/ },
      { name: "Unix", regex: /X11/i, versionRegex: null },
      { name: "FreeBSD", regex: /FreeBSD/i, versionRegex: null },
      { name: "OpenBSD", regex: /OpenBSD/i, versionRegex: null },
      { name: "NetBSD", regex: /NetBSD/i, versionRegex: null }

    ];

    for (const { name, regex, versionRegex } of osMap) {
      if (regex.test(userAgent) || regex.test(platform)) {
        let version = "Unknown";
        if (versionRegex) {
          const match = userAgent.match(versionRegex);
          if (match) {
            version = match[1].replace(/_/g, ".");  // Replace underscores with dots for consistency
          }
        }
        return { os: name, osVersion: version };
      }
    }

    return { os: "Unknown", osVersion: "Unknown" }; // If the platform is not recognized, return 'Unknown'
  } catch (error) {
    console.log("Error : ", error);

  }
}

// Function to detect the user's browser
function getBrowser() {
  try {
    const ua = navigator.userAgent.toLowerCase();
    let browser, versionMatch, browserVersion;
    if (ua.includes("edg")) {
      browser = "Edge";
      versionMatch = ua.match(/edg[\/\s](\d+(\.\d+)?)/);
      browserVersion = versionMatch ? versionMatch[1] : "Unknown";
      return {
        browser: browser,
        browserVersion: browserVersion
      }
    }
    if (ua.includes("opr") || ua.includes("opera")) {
      browser = "Opera";
      versionMatch = ua.match(/(?:opera|opr)[\/\s](\d+(\.\d+)?)/);
      browserVersion = versionMatch ? versionMatch[1] : "Unknown";
      return {
        browser: browser,
        browserVersion: browserVersion
      }
    } if (ua.includes("vivaldi")) {
      browser = "Vivaldi";
      versionMatch = ua.match(/vivaldi[\/\s](\d+(\.\d+)?)/);
      browserVersion = versionMatch ? versionMatch[1] : "Unknown";
      return {
        browser: browser,
        browserVersion: browserVersion
      }
    } if (ua.includes("brave")) {
      browser = "Brave";
      versionMatch = ua.match(/chrome[\/\s](\d+(\.\d+)?)/); // Brave uses Chromium
      browserVersion = versionMatch ? versionMatch[1] : "Unknown";
      return {
        browser: browser,
        browserVersion: browserVersion
      }
    } if (ua.includes("samsung")) {
      browser = "Samsung Internet";
      versionMatch = ua.match(/samsungbrowser[\/\s](\d+(\.\d+)?)/);
      browserVersion = versionMatch ? versionMatch[1] : "Unknown";
      return {
        browser: browser,
        browserVersion: browserVersion
      }
    } if (ua.includes("firefox")) {
      browser = "Firefox";
      versionMatch = ua.match(/firefox[\/\s](\d+(\.\d+)?)/);
      browserVersion = versionMatch ? versionMatch[1] : "Unknown";
      return {
        browser: browser,
        browserVersion: browserVersion
      }
    } if (ua.includes("chrome")) {
      browser = "Chrome";
      versionMatch = ua.match(/chrome[\/\s](\d+(\.\d+)?)/);
      browserVersion = versionMatch ? versionMatch[1] : "Unknown";
      return {
        browser: browser,
        browserVersion: browserVersion
      }
    } if (ua.includes("safari")) {
      browser = "Safari";
      versionMatch = ua.match(/version[\/\s](\d+(\.\d+)?)/);
      browserVersion = versionMatch ? versionMatch[1] : "Unknown";
      return {
        browser: browser,
        browserVersion: browserVersion
      }
    } if (ua.includes("msie") || ua.includes("trident")) {
      browser = "IE";
      versionMatch = ua.match(/(?:msie |rv:)(\d+(\.\d+)?)/);
      browserVersion = versionMatch ? versionMatch[1] : "Unknown";
      return {
        browser: browser,
        browserVersion: browserVersion
      }
    } else {
      return {
        browser: "Unknown",
        browserVersion: "Unknown"
      }
    }
  } catch (error) {
    console.log("Error : ", error);

  }
}

// Retrieve values from the dataLayer, falling back to cookies if not available

// Get the 'pageEnvironment' from the dataLayer or an empty string if not found
var pageEnvironment = window.dataLayer && window.dataLayer.find(item => item.pageEnvironment) ? window.dataLayer.find(item => item.pageEnvironment).pageEnvironment : '';

// Get the 'pageContentType' from the dataLayer or an empty string if not found
var pageContentType = window.dataLayer && window.dataLayer.find(item => item.pageContentType) ? window.dataLayer.find(item => item.pageContentType).pageContentType : '';

// Get the 'pageName' from the dataLayer or an empty string if not found
var pageName = window.dataLayer && window.dataLayer.find(item => item.pageName) ? window.dataLayer.find(item => item.pageName).pageName : '';

// Get the 'loggedIn' status from the dataLayer or an empty string if not found
var loggedIn = window.dataLayer && window.dataLayer.find(item => item.loggedIn) ? window.dataLayer.find(item => item.loggedIn).loggedIn : '';

// Get the 'consentVersion' from the dataLayer or an empty string if not found
var consentVersion = window.dataLayer && window.dataLayer.find(item => item.consentVersion) ? window.dataLayer.find(item => item.consentVersion).consentVersion : '';

// Dynamically retrieve 'type' from the dataLayer or cookies, with a fallback to cookies if dataLayer is unavailable
var type = window.dataLayer && window.dataLayer.find(item => item.type) ? window.dataLayer.find(item => item.type).type : getCookie('type') || '';

// Dynamically retrieve 'segment' from the dataLayer or cookies, with a fallback to cookies if dataLayer is unavailable
var segment = window.dataLayer && window.dataLayer.find(item => item.segment) ? window.dataLayer.find(item => item.segment).segment : getCookie('segment') || '';

// Dynamically retrieve 'customerId' from the dataLayer or cookies, with a fallback to cookies if dataLayer is unavailable
var customerId = window.dataLayer && window.dataLayer.find(item => item.customerId) ? window.dataLayer.find(item => item.customerId).customerId : getCookie('customerId') || '';

// Function to fetch the user's location data (country, region, and city) using an external API (ipinfo.io)

async function getLocation() {
  try {
    let locationFlag = sessionStorage.getItem("locationObj");
    if (locationFlag) {
      return JSON.parse(sessionStorage.getItem("locationObj"))
    }
    // Fetch location data from the IPInfo API
    const response = await fetch('https://ipinfo.io/json?token=18ac67736ea79a');
    const data = await response.json();  // Parse the JSON response
    // Return location data (country, region, city) or 'Unknown' if any data is missing
    let locationObj = {
      country: data.country || 'Unknown',
      region: data.region || 'Unknown',
      city: data.city || 'Unknown'
    };
    sessionStorage.setItem("locationObj", JSON.stringify(locationObj));
    return locationObj;
  } catch (error) {
    // Handle any errors that occur during the fetch
    let locationObj = {
      country: 'Unknown',
      region: 'Unknown',
      city: 'Unknown'
    };
    console.log('Error fetching location data', error);
    sessionStorage.setItem("locationObj", JSON.stringify(locationObj));
    return locationObj;
  }
}
async function getUserInfo(additionalData = {}) {
  try {
    const locationData = await getLocation();
    const deviceInfo = getDeviceType();
    const browserInfo = getBrowser();
    const osInfo = getOS();
    userObj = {
      userId: userID, // The unique user ID (retrieved from cookies)
      customerId: additionalData.customerId || customerId, // The customer ID (retrieved from cookies)
      gaId: getGAClientId() || '', // Google Analytics client ID (if available)
      loggedIn: loggedIn || '', // Whether the user is logged in (from dataLayer or cookies)
      type: type, // Type of user (mobile/desktop, from dataLayer or cookies)
      segment: segment, // The user's segment (from dataLayer or cookies)
      device: deviceInfo.deviceType, // The device type (mobile/desktop)
      screenWidth: deviceInfo.screenWidth,
      screenHeight: deviceInfo.screenHeight,
      os: osInfo.os, // The user's operating system (e.g., Windows, macOS)
      osVersion: osInfo.osVersion,
      browser: browserInfo.browser, // The browser being used (e.g., Chrome, Firefox)
      browserversion: browserInfo.browserVersion,
      location: {
        country: locationData.country, // Country from location data
        region: locationData.region, // Region from location data
        city: locationData.city // City from location data
      }
    }
    localStorage.setItem("userObject", JSON.stringify(userObj));
  } catch (error) {
    console.log("Error : ", error);

  }
}

async function getPageInfo(additionalData = {}) {
  try {
    console.log(" getPageInfo ", window.location);
    pageObj = {
      pageUrl: window.location.href, // The full URL of the page
      pageTitle: document.title, // The title of the page
      pageReferrer: document.referrer, // The referrer URL (if available)
      pagePath: window.location.pathname, // The path portion of the URL (e.g., "/home")
      pageHostname: window.location.hostname, // The hostname (e.g., "example.com")
      pageLanguage: navigator.language || '', // Language setting of the user's browser
      pageContentType: pageContentType, // The content type (retrieved from dataLayer or cookies)
      pageName: additionalData.pageName || pageName || '', // The name of the page (can be passed in as a parameter)
      pageLoadTime: performance.now() || '',
      environment: pageEnvironment // The environment (e.g., production, staging) from dataLayer
    }
    localStorage.setItem("pageObject", JSON.stringify(pageObj));
  } catch (error) {
    console.log("Error : ", error);

  }
}

function checkCookie(cookieName) {
  try {
    // Get all cookies as a single string
    const cookies = document.cookie;
    // Check if the cookie name exists in the cookies string
    const cookieExists = cookies.split(';').some(cookie => cookie.trim().startsWith(`${cookieName}=`));
    return cookieExists;
  } catch (error) {
    console.log("Error : ", error);

  }
}
let domainArray = ['example.com', 'vercel.app', 'anotherdomain.com']
// Function to structure the consent payload
async function consentPayload(allConsented, allConsentsGiven, cmpId, gdprApplies, gdprConsent, eventName, vendorConsentedPurposes) {
  // Prepare the purposes object dynamically based on allConsented data
  try {
    let purposes = [];
    let consentPurpose = {};
    let vendorPurposes = [];
    let vendorPurpose = {};
    let trackStatus = allConsentsGiven ? 'optedIn' : 'optedOut';
    userID = getCookie('userID');
    sessionID = getCookie('sessionID');
    rdUserID = getCookie('rdUserId');
    if (allConsentsGiven) {
      if (!userID) {
        // If no userID exists in the cookies, generate a new one
        userID = generateUserID();
        setPersistentCookie('userID', userID, 365);
      }
      // If no sessionID exists (e.g., it's a new session), create a new session ID
      if (!sessionID) {
        sessionID = crypto.randomUUID(); //Math.random().toString(36).substr(2, 9); // Generate a random session ID (9 characters)
        setSessionCookie('sessionID', sessionID); // Store session ID as a session cookie (expires when the browser is closed)  
      }
      if (!rdUserID) {
        let referenceDomainUserId = getQueryParam('uid');
        if (referenceDomainUserId) {
          rdUserID = referenceDomainUserId;
          setPersistentCookie('rdUserId', referenceDomainUserId, 365);
        }
      }

    }
    document.querySelectorAll('a').forEach(link => {
      let url = new URL(link.href);
      let domain = url.hostname.split('.').slice(-2).join('.');
      if (url.hostname !== window.location.hostname) {
        if (allConsentsGiven && domainArray.includes(domain)) {
          url.searchParams.set('uid', userID);
        }
        else {
          url.searchParams.delete('uid');
        }
        link.href = url.toString();
      }
    });



    // Loop through all the purposes and set them as true/false in the purposes object
    allConsented.forEach(purpose => {
      consentPurpose = {};
      consentPurpose['name'] = purpose.name;
      consentPurpose['isConsented'] = purpose.isConsented;
      consentPurpose['Id'] = purpose.Id; // Mark as true/false based on consented status
      purposes.push(consentPurpose);
    });

    // Loop through all the purposes and set them as true/false in the purposes object
    vendorConsentedPurposes.forEach(purpose => {
      vendorPurpose = {};
      vendorPurpose['name'] = purpose.name;
      vendorPurpose['isConsented'] = purpose.isConsented;
      vendorPurpose['Id'] = purpose.Id; // Mark as true/false based on consented status
      vendorPurposes.push(vendorPurpose);
    });

    consentObj = {
      status: trackStatus, // Set status based on whether all mandatory consents are given
      purposes: {
        purposes, // Dynamic purposes based on the consent data
      },
      vendorConsent: {
        vendorPurposes
      }
    };
    console.log('consentObj : ' + JSON.stringify(consentObj));
    localStorage.setItem("consentObject", JSON.stringify(consentObj));
    cmpEventData = {
      eventName: eventName,
      status: trackStatus, // Set status based on whether all mandatory consents are given
      purposes: {
        purposes, // Dynamic purposes based on the consent data
      },
      vendorConsent: {
        vendorPurposes
      },
      cmpId: cmpId,
      gdprApplies: gdprApplies,
      gdprConsent: gdprConsent,
      userId: userID
    };
    return cmpEventData
  } catch (error) {
    console.log("Error : ", error);

  }
};

// Fetch vendor list function
async function getVendorList(vendorPurposeConsents) {
  try {
    const response = await fetch('https://cdn.cookielaw.org/vendorlist/iab2Data.json');
    if (!response.ok) {
      throw new Error(`HTTP error! Status: ${response.status}`);
    }
    var data = await response.json();
    const userVendorConsentedPurposes = [];
    var vendorConsents = data.vendors;
    var i = 1;
       for (let [key1, value1] of Object.entries(vendorPurposeConsents)) {
      for (let [key2, value2] of Object.entries(vendorConsents)) {
        // Ensure vendor has an ID before accessing tcData
        if (key1 === key2) {
          const purposeConsent = vendorPurposeConsents[key1] || false;
          userVendorConsentedPurposes.push({
            Id: key1,
            isConsented: purposeConsent || false,
            name: vendorConsents[key2].name
          });
        }
      }
    }
    return userVendorConsentedPurposes;
  } catch (error) {
    console.log("Error : ", error);
  }
};

// Function to check if all required consents are given
function hasAllConsents(allConsented) {
  try {
    // Mandatory purposes
    const requiredPurposeIds = [
      "1", // Store and/or access information on a device
      "3", // Create profiles for personalised advertising
      "4" //,  // Use profiles to select personalised advertising
      //"5",  // Create profiles to personalise content
      //"6",  // Use profiles to select personalised content
      //"9",  // Understand audiences through statistics
      //"10"   // Develop and improve services
    ];

    // Check if each required purpose ID is present in the allConsented array
    return requiredPurposeIds.every(purposeId =>
      allConsented.some(p => p.Id === purposeId));
  } catch (error) {
    console.log("Error : ", error);

  }
}

const callback = (tcData, success) => {
  try {
    if (success && tcData.eventStatus === 'useractioncomplete') {

      const consent_purposes = [{

        _id: '1',
        name: 'Store Information on Device'
      }, {
        _id: '2',
        name: 'Use limited data to select advertising'
      }, {
        _id: '3',
        name: 'Create profiles for personalised advertising'
      }, {
        _id: '4',
        name: 'Use profiles to select personalised advertising'
      }, {
        _id: '5',
        name: 'Create profiles to personalise content'
      }, {
        _id: '6',
        name: 'Use profiles to select personalised content'
      }, {
        _id: '7',
        name: 'Measure advertising performance'
      }, {
        _id: '8',
        name: 'Measure content performance'
      }, {
        _id: '9',
        name: 'Understand audiences through statistics or combinations of data from different sources'
      }, {
        _id: '10',
        name: 'Develop and improve services'
      }
      ];

      const vendor_purposes = [{

        _id: '11',
        name: 'Quantcast'
      }, {
        _id: '22',
        name: 'admetrics GmbH'
      }, {
        _id: '25',
        name: 'Yahoo EMEA Limited'
      }, {
        _id: '48',
        name: 'NetSuccess, s.r.o'
      }, {
        _id: '49',
        name: 'Jellyfish France'
      }, {
        _id: '50',
        name: 'Adform A/S'
      }, {
        _id: '68',
        name: 'Amazon Ad Server'
      }, {
        _id: '69',
        name: 'OpenX'
      }, {
        _id: '71',
        name: 'Roku Advertising Services'
      }, {
        _id: '76',
        name: 'Pubmatic, Inc'
      }
      ];

      //var consents = "";
      //var vendorConsents = "";

      // Call __tcfapi to fetch consents
      __tcfapi('getTCData', 2, async function (tcData, success) {

        if (success && tcData.eventStatus === 'useractioncomplete') {

          consents = tcData.purpose.consents;
          vendorConsents = tcData.vendor.consents;
          cmpId = tcData.cmpId;
          gdprApplies = tcData.gdprApplies;
          gdprConsent = tcData.tcString;

          const userConsentedPurposes = [];
          const consentedPurposes = [];
          const allConsented = [];

          // For the cookie
          consent_purposes.forEach(function (purpose) {
            // Check if the user has consented to each purpose based on the TCData
            const purposeConsent = tcData.purpose.consents[purpose._id];

            userConsentedPurposes.push({
              Id: purpose._id,
              isConsented: purposeConsent || false
              //name: purpose.name
            });

          });

          //For the payload
          consent_purposes.forEach(function (purpose) {
            // Check if the user has consented to each purpose based on the TCData
            const purposeConsent = tcData.purpose.consents[purpose._id];
            consentedPurposes.push({
              Id: purpose._id,
              isConsented: purposeConsent || false,
              name: purpose.name
            });

          });
          /// code from 291 to 305 needs to commented/removed once we use getVendorList function output
          const vendorConsentedPurposes = [];

          vendor_purposes.forEach(function (vendor) {
            // Check if the user has consented to each purpose based on the TCData
            const vendorConsent = tcData.vendor.consents[vendor._id];
            vendorConsentedPurposes.push({
              Id: vendor._id,
              isConsented: vendorConsent || false,
              name: vendor.name
            });
          });

          // Generated the vendor list from Vendor API 
          var vendorPurposeConsents = tcData.vendor.consents;
          var vendorData = await getVendorList(vendorPurposeConsents); /// result from this function is the new vendor consent array this needs to be passed to consentPayload function
          // Generate the consented purposes payload, marking true or false based on matching with consent_purposes

          consent_purposes.forEach(function (purpose) {
            // Check if the user has consented to each purpose based on the TCData
            const purposeConsent = tcData.purpose.consents[purpose._id] || false;
            if (purposeConsent) {
              allConsented.push({
                Id: purpose._id,
                isConsented: purposeConsent,
                name: purpose.name
              });
            }
          });
          // Check if all required purposes are consented
          var eventName;
          var allConsentsGiven = hasAllConsents(allConsented);
          var deleteProfile = false; // static flag which can be altered as per client reqt
          // var consentTrack = localStorage.getItem("consentTrack");
          consentTrack = getCookie('consentTrack');
          if ((consentTrack === null && allConsentsGiven === true) || (consentTrack === 'false' && allConsentsGiven === true && deleteProfile === false)) {
            eventName = 'setConsent';
          } else if ((consentTrack === 'true' && allConsentsGiven === true) || (allConsentsGiven === false && deleteProfile === false)) {
            eventName = 'updateConsent';
          } else if (consentTrack === 'true' && allConsentsGiven === false && deleteProfile === true) {
            eventName = 'deleteProfile';
          }
          // Call consentPayload function to structure the payload if all consents are given
          const payload = await consentPayload(consentedPurposes, allConsentsGiven, cmpId, gdprApplies, gdprConsent, eventName, vendorData);
          console.log(" consent payload ", payload);
          if ((consentTrack === null && allConsentsGiven === true) || (consentTrack === 'false' && allConsentsGiven === true && deleteProfile === false)) {

            console.log('Formatted Payload:', payload);
            await sendEventToAPI(payload);
            setPersistentCookie('consentTrack', allConsentsGiven);
            consentTrack = allConsentsGiven;
            setPersistentCookie('userConsentedPurposes', JSON.stringify(userConsentedPurposes));

          } else if ((consentTrack === 'true' && allConsentsGiven === true) || (allConsentsGiven === false && deleteProfile === false)) {
            // this line to be updated if deleteProfile flag is false
            console.log('Formatted Payload:', payload);

            await sendEventToAPI(payload);
            //localStorage.setItem('userConsentedPurposes', JSON.stringify(userConsentedPurposes));
            setPersistentCookie('userConsentedPurposes', JSON.stringify(userConsentedPurposes));
            setPersistentCookie('consentTrack', allConsentsGiven);
            consentTrack = allConsentsGiven;
            // Update local variable consentTrack if deleteProfile flag is false

          } else if (allConsentsGiven === false && deleteProfile === true) {

            await sendEventToAPI(payload);
            localStorage.clear();
            sessionStorage.clear();
            cookieStore.delete("consentTrack");
            cookieStore.delete("userConsentedPurposes");
            cookieStore.delete("userID");
            cookieStore.delete("sessionID");
            consentTrack = false;
            ['utm_source', 'utm_medium', 'utm_campaign', 'utm_term', 'utm_content'].forEach(param => {
              cookieStore.delete(param);  // Set the UTM parameter as a persistent cookie  
            });

            const checkRdCookie = checkCookie('rdUserId');
            if (checkRdCookie) {
              cookieStore.delete("rdUserId");
            }

          }

          console.log("consentTrack 1 ", consentTrack)
          if (allConsentsGiven) {
            let userObjFlag = localStorage.getItem("userObject");
            if (userObjFlag) {
              userObj = JSON.parse(localStorage.getItem("userObject"))
            }
            else {
              await getUserInfo();
            }
            let pageObjFlag = localStorage.getItem("pageObject");
            if (pageObjFlag) {
              pageObj = JSON.parse(localStorage.getItem("pageObject"))
            }
            else {
              await getPageInfo();
            }
          }
        } else {
          console.log('Failed to retrieve consent data. Success flag is false.');

        };

        window.__tcfapi('removeEventListener', 2, (success) => {

          if (success) {
            console.log("Removed callback after calling once");
          }
        }, callback);

      })
    }
  } catch (error) {
    console.log("Error : ", error);

  }
};

function waitForTCFAPI(callback, retries = 10, interval = 500) {
  try {
    let attempts = 0;
    let check = setInterval(() => {
      if (typeof window.__tcfapi === "function") {
        clearInterval(check);
        callback();
      } else if (attempts >= retries) {
        clearInterval(check);
        console.error("_tcfapi did not become available.");
      }
      attempts++;
    }, interval);
  } catch (error) {
    console.log("Error : ", error);

  }
}
waitForTCFAPI(() => {
  console.log("_tcfapi is ready!");
  window.__tcfapi('addEventListener', 2, callback);
});

async function createEventData(eventname, eventCategory, additionalData = {}) {
  try {
    const utmParams = getUTMParams();
    // Generate a random event ID for tracking purposes
    const randomEventId = Math.floor(100000000 + Math.random() * 900000000);
    var eventData = {
      eventInfo: {
        eventName: eventname, // Event name
        eventId: randomEventId, // Randomly generated event ID
        eventTimestamp: new Date().toISOString(), // Event timestamp in ISO format
        eventCategory: eventCategory // Event category (could be used for categorizing types of events)
      },
      pageInfo: pageObj,
      userInfo: userObj,
      sessionInfo: {
        sessionId: sessionID, // The current session ID (from cookies)
        startTime: new Date().toISOString(), // Session start time (ISO format)
        source: utmParams.utm_source || getCookie('utm_source') || '', // UTM source (from URL query params)
        medium: utmParams.utm_medium || getCookie('utm_medium') || '', // UTM medium (from URL query params)
        campaign: utmParams.utm_campaign || getCookie('utm_campaign') || '', // UTM campaign (from URL query params)
        content: utmParams.utm_content || getCookie('utm_content') || '', // UTM content (from URL query params)
      },
      consent: consentObj
    }
    if (rdUserID) {
      eventData.userInfo.rdUserId = rdUserID
    }
    if (eventCategory == "Low Page speed") {
      eventData.eventInfo.pageLoadTime = performance.now() || ''
    }
    return eventData;
  } catch (error) {
    console.log("Error : ", error);

  }
};

///////////////////////////////////////////////// Tracking Using Function///////////////////////////////////////////

(function () {
  // Declare a global variable for analytics tracking
  var globalAnalyticsKey = "analytics";
  var analytics = window[globalAnalyticsKey] = window[globalAnalyticsKey] || [];

  // Check if the analytics snippet has already been invoked to avoid duplication
  if (analytics.invoked) {
    if (window.console && console.error) {
      console.error("Analytics snippet included twice.");
    }
    return; // Exit if analytics is already initialized
  }

  analytics.invoked = true; // Mark that the snippet has been invoked

  // Function to track a "Page View" event asynchronously
  analytics.pageView = async function (pageName = '', properties = {}) {
    try {
      console.log(" analytics.pageView consentTrack ", consentTrack)
      if (consentTrack) {
        await getPageInfo({ pageName, ...properties })
        var eventData = await createEventData("page View", "page", { pageName, ...properties })
        // Push the event data into the analytics array for tracking
        const eventProperties = { ...properties };
        // Include the additional properties in the event data under pageInfo
        eventData = {
          ...eventData,
          pageInfo: {
            ...eventData.pageInfo,
            properties: eventProperties // Add the additional properties here
          }
        };

        pageObj = eventData.pageInfo;
        localStorage.setItem("pageObject", JSON.stringify(eventData.pageInfo));
        analytics.push(['page', eventData]);
        console.log("analytics.pageview eventData ", eventData);
        // Send the event data to an API for further processing or storage
        analytics.sendEventToAPI(eventData);
      }
    } catch (error) {
      console.log("Error : ", error);
    }
  }
  // Function to track "User Identity" events
  analytics.userIdentity = async function (customerId = '', properties = {}) {
    try {
      console.log(" analytics.userIdentity consentTrack ", consentTrack)
      if (consentTrack) {
        await getUserInfo({ customerId, ...properties })
        var eventData = await createEventData("User Identity", "user", { customerId, ...properties });
        // Merge any additional properties passed into the function with the userInfo properties
        const eventProperties = { ...properties };
        // Include the additional properties in the event data under userInfo
        eventData = {
          ...eventData,
          userInfo: {
            ...eventData.userInfo,
            properties: eventProperties // Add the extra properties to the userInfo section
          }
        };
        userObj = eventData.userInfo;
        localStorage.setItem("userObject", JSON.stringify(eventData.userInfo));
        // Push the event data to the analytics array for tracking (this will be processed by analytics services)
        analytics.push(['track', eventData]);
        console.log("analytics.userIdentity eventData ", eventData);
        // Send the event data to an API (for server-side tracking or storage)
        analytics.sendEventToAPI(eventData);
      };
    } catch (error) {
      console.log("Error : ", error);
    }
  }

  // Function to track a custom event
  analytics.trackCustomEvent = async function (eventName, properties = {}) {
    try {
      console.log(" analytics.trackCustomEvent consentTrack ", consentTrack)
      if (consentTrack) {
        var eventData = await createEventData(eventName, "custom event", properties);
        // Merge any custom properties passed into the function with the event data
        const eventProperties = { ...properties };
        // Add the custom properties to the event data (specifically to eventInfo)
        eventData = {
          ...eventData,
          eventInfo: {
            ...eventData.eventInfo,
            properties: eventProperties // Add custom properties to the eventInfo object
          }
        };
        // Push the event data to the analytics array for tracking purposes
        analytics.push(['track', eventData]);
        console.log("analytics.trackCustomEvent eventData ", eventData);
        // Send the event data to an API for further processing or storage
        analytics.sendEventToAPI(eventData);
      };
    } catch (error) {
      console.log("Error : ", error);
    }
  }
  // Function to send event data to an API
  analytics.sendEventToAPI = async function (eventData) {
    try {
       console.log('Sending event data to API:', eventData);
      // Make an asynchronous POST request to the API to send event data
      const response = await fetch('https://web-analytics-dot-uxlwqzc-cdip-sandbox-test.uc.r.appspot.com/sendevent', {
        method: 'POST', // HTTP method (POST for sending data)
        headers: {
          'Content-Type': 'application/json', // Specify the content type as JSON
          'apikey': '12345abc' // API key for authentication
        },
        body: JSON.stringify({ eventData }) // Send the event data as a JSON object
      });

      // Parse the response from the API as JSON
      const result = await response.json();

      // Log success message with the API response
      console.log('Event tracked successfully', result);
    } catch (error) {
      console.log(" Error : ", error);
    }
  };
}());

//////////////////////////////// AUTOMATIC TRACKING CODE /////////////////////////////////////////////////////

// Enable automatic tracking and analytics if both conditions are true
let automaticTracking = true;
//let consentanalytics = true;
// Function to send event data to the external API
async function sendEventToAPI(eventData) {
  console.log("sendEventToAPI 1")
  try {
    // Send the event data to the API using a POST request
    const response = await fetch('https://web-analytics-dot-uxlwqzc-cdip-sandbox-test.uc.r.appspot.com/sendevent', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',  // Set the content type to JSON
        'apikey': '12345abc',  // Provide the API key for authentication
      },
      body: JSON.stringify(eventData),  // Convert the event data to a JSON string and send it as the body of the request
    });

    // Check if the request was successful
    if (response.ok) {
      const result = await response.json();  // Parse the JSON response
      console.log('Event tracked successfully:', result);  // Log the success
    } else {
      console.error('Error sending data:', response.statusText);  // Log an error if the request failed
    }
  } catch (error) {
    console.log("Error : ", error);
  }

}
async function errorEvent(eventCategory) {
  try {
    if (consentTrack) {
      let eventName = "Errors"
      if (eventCategory == "Low Page speed") {
        eventName = "Page Performance Issue"
      }
      var eventData = await createEventData(eventName, eventCategory)
      console.log("errorEvent eventData ", eventData);
      await sendEventToAPI(eventData);
    }
  } catch (error) {
    console.log("Error : ", error);
  }

}

//  if (automaticTracking === true && consentanalytics === true) {
if (automaticTracking === true) {
  // Function to capture a page view event
  async function trackPageView() {
    try {
      console.log(" trackPageView consentTrack ", consentTrack)
      if (consentTrack) {
        await getPageInfo();
        var eventData = await createEventData("Page View", "page");
        console.log("trackPageView eventData ", eventData);
        console.log("trackPageView eventData.pageInfo ", JSON.stringify(eventData.pageInfo));
        pageObj = eventData.pageInfo;
        localStorage.setItem("pageObject", JSON.stringify(eventData.pageInfo));
        // Send the event data to the dataLayer
        await sendEventToAPI(eventData);
      }
    } catch (error) {
      console.log("Error : ", error);
    }
  }

  // Object to keep track of scroll percentages
  let scrollTracked = { 25: false, 50: false, 75: false, 100: false };

  // Function to track scroll depth
  function trackScroll() {
    try {
      console.log(" trackScroll consentTrack ", consentTrack)
          // Add an event listener to the scroll event
      window.addEventListener('scroll', function () {
        // Calculate the current scroll position (distance from top) + visible window height
        const scrollPosition = window.scrollY + window.innerHeight;
        // Get the total height of the document (including the part that isn't visible)
        const documentHeight = document.documentElement.scrollHeight;
        // Calculate the percentage of the page that has been scrolled
        const scrollPercent = (scrollPosition / documentHeight) * 100;
        if (consentTrack) {
          // If the user has scrolled past 99.9% and the 100% event hasn't been tracked yet
          if (scrollPercent >= 99.9 && !scrollTracked[100]) {
            sendScrollEvent(100);  // Send event for 100% scroll depth
            scrollTracked[100] = true;  // Mark that 100% has been tracked
          }
          // If the user has scrolled between 75% and 99.9% and the 75% event hasn't been tracked yet
          else if (scrollPercent >= 75 && scrollPercent < 100 && !scrollTracked[75]) {
            sendScrollEvent(75);  // Send event for 75% scroll depth
            scrollTracked[75] = true;  // Mark that 75% has been tracked
          }
          // If the user has scrolled between 50% and 75% and the 50% event hasn't been tracked yet
          else if (scrollPercent >= 50 && scrollPercent < 75 && !scrollTracked[50]) {
            sendScrollEvent(50);  // Send event for 50% scroll depth
            scrollTracked[50] = true;  // Mark that 50% has been tracked
          }
          // If the user has scrolled between 25% and 50% and the 25% event hasn't been tracked yet
          else if (scrollPercent >= 25 && scrollPercent < 50 && !scrollTracked[25]) {
            sendScrollEvent(25);  // Send event for 25% scroll depth
            scrollTracked[25] = true;  // Mark that 25% has been tracked
          }
        };
      });
    } catch (error) {
      console.log("Error : ", error);
    }
  }

  // Function to send scroll data to tracking platforms (e.g., Google Analytics, API)
  async function sendScrollEvent(percentage) {
    try {
      console.log(" sendScrollEvent consentTrack ", consentTrack)
      if (consentTrack) {
        var eventData = await createEventData("Scroll", "scroll depth");
        eventData.eventInfo.scroll_percentage = percentage;
        console.log("sendScrollEvent eventData ", eventData);
        await sendEventToAPI(eventData);
      }
    } catch (error) {
      console.log("Error : ", error);
    }
  }

  // Function to track button clicks
  async function trackButtonClick(event) {
    try {
      console.log(" trackButtonClick consentTrack ", consentTrack)
      if (consentTrack) {
        const button = event.target;  // The target of the event (i.e., the button clicked)
        console.log(" trackButtonClick button ", button)
        var eventData = await createEventData("Button Click", "interaction");
        eventData.eventInfo.buttonId = button.id || "",  // Button ID or " " if not available;  
          eventData.eventInfo.buttonText = button.innerText || button.value || "",  // Button text or value
          console.log("trackbuttonclick eventData ", eventData);
        // Send the button click event data to the dataLayer
        await sendEventToAPI(eventData);
      }
    } catch (error) {
      console.log("Error : ", error);
    }
  }

  function trackIframeVideos() {
    try {
      console.log(" trackIframeVideos consentTrack ", consentTrack)
      if (consentTrack) {
        // Check for YouTube or Vimeo iframe
        document.querySelectorAll('iframe').forEach(iframe => {
          let src = iframe.src;
          if (src.includes("youtube.com") || src.includes("youtu.be")) {
            setupYouTubeTracking(iframe);
          } else if (src.includes("vimeo.com")) {
            setupVimeoTracking(iframe);
          }
        });
      }
    } catch (error) {
      console.log("Error : ", error);
    }
  }
  function setupYouTubeTracking(iframe) {
    try {
      console.log("setupYouTubeTracking");
      if (!iframe.id) {
        iframe.id = "yt-" + Math.random().toString(36).substr(2, 9); // Assign a unique ID if missing
      }
      let tag = document.createElement('script');
      tag.src = "https://www.youtube.com/iframe_api";
      document.head.appendChild(tag);

      window.onYouTubeIframeAPIReady = function () {
        let player = new YT.Player(iframe.id, {
          events: {
            'onStateChange': function (event) {
              if (event.data === YT.PlayerState.PLAYING) {
                trackButtonClick(event); // Call your tracking function here
              }
            }
          }
        });
      };
    } catch (error) {
      console.log("Error : ", error);
    }
  }

  function setupVimeoTracking(iframe) {
    try {
      console.log("setupVimeoTracking");
      // let player = new Vimeo.Player(iframe);
      // player.on('play', function(event) {
      // trackButtonClick(event); // Call your tracking function here
      // });
    } catch (error) {
      console.log("Error : ", error);
    }
  }

  // Function to get LCP

  function getLCP() {
    let lcpEntry;
    const observer = new PerformanceObserver((entryList) => {
      const entries = entryList.getEntries();
      lcpEntry = entries[entries.length - 1];
    });
    observer.observe({ type: "largest-contentful-paint", buffered: true });
    return lcpEntry ? lcpEntry.startTime : 0;
  }
  // Function to get TTI (simplified)

  function getTTI() {
    return performance.timing.domInteractive - performance.timing.navigationStart;
  }

  async function handleOutboundRequest(target) {
    let url = target.dataset.href || target.href;
    if (!url) return;
    try {
      let response = await fetch(url, { method: "HEAD" });
      if (!response.ok && response.status >= 400 && response.status < 600) {
        await errorEvent(response.status);
      }
    } catch (error) {
      console.error(`Network error checking: ${url}`, error);
    }
  }

  // Function to handle form submissions
  async function handleFormSubmission(form) {
    let formData = new FormData(form);
    let actionUrl = form.action;
    if (actionUrl) {
      const actionResponse = await fetch(actionUrl, { method: "HEAD" }); // Check if the page exists
      console.log(`${actionUrl} response:`, actionResponse);
      if (!actionResponse.ok && actionResponse.status >= 400 && actionResponse.status < 600) {
        await errorEvent(actionResponse.status);
        return;
      }
    }
    try {
      let response = await fetch(form.action, {
        method: form.method || "POST",
        body: formData,
      });
      console.log(`Form submission response:`, response);
      if (!response.ok && response.status >= 400 && response.status < 600) {
        await errorEvent(response.status);
      } else {
        console.log("Form submitted successfully");
        window.open(form.action); // Open if successful
      }
    } catch (error) {
      console.error("Network error:", error);
    }
  }
  document.addEventListener('DOMContentLoaded', function () {
    try {
      console.log("addEventListener  DOMContentLoaded ")
      // Track page view and scroll events after the DOM is loaded
      trackPageView();  // Track page load (page view event)
      trackScroll();    // Track scroll events (scroll depth tracking)
      trackIframeVideos();
      document.addEventListener('click', async function (event) {
        let target = event.target.closest('button, iframe, form, a, [role="button"], img[onclick], [onclick]'); // Get the nearest element
        if (!target) return;
        try {
          if (target) {
            trackButtonClick(event);
          }
          if (target.tagName === "A" || target.tagName === "BUTTON") {
            let form = target.closest("form"); // Check if the button belongs to a form
            if (form) return; // Skip if inside a form (form submission will handle it)
            await handleOutboundRequest(target);
          }
        } catch (error) {
          console.log("Error addEventListener trackButtonClick : ", error);
        }
      });
      document.addEventListener("submit", async function (event) {
        try {
          let form = event.target.closest("form");
          if (!form) return;
          // event.preventDefault(); // Stop default form submission
          await handleFormSubmission(form);
        } catch (error) {
          console.log("Error : ", error);
        }

      });
    } catch (error) {
      console.log("Error : ", error);
    }
  });
  window.addEventListener("load", () => {
    setTimeout(() => {
      const performanceData = performance.getEntriesByType("navigation")[0];
      console.log(" performanceData ", performanceData)
        if (performanceData) {
        const lcp = getLCP();
        const tti = getTTI();
        const loadTime = performanceData.loadEventEnd - performanceData.startTime;
        if (lcp > 4000 || tti > 5000 || loadTime > 7000) {
          errorEvent("Low Page speed");
        }
      }
    }, 0);
  });

  function getCookieval(name) {
    const value = `; ${document.cookie}`;
    const parts = value.split(`; ${name}=`);
    if (parts.length === 2) return parts.pop().split(';').shift();
    // Return undefined if cookie not found
    return undefined;
  }
   
  // The specific name of the cookie to read from THIS domain ('testinovation-cdp.vercel.app')
  const thirdPartyCookieName = 'userID';
   
  // The origin of the PARENT window (YOUR HOST DOMAIN) that is allowed to receive the message.
  // Use the specific origin provided by the user.
  const parentOrigin = 'https://development-site-three.vercel.app'; 
   
  console.log(`[IFRAME] Page loaded. Cookie to find: '${thirdPartyCookieName}'. Target parent origin: '${parentOrigin}'`);
   window.addEventListener('load', () => {
     debugger;
    console.log('[IFRAME] Window load event fired.');
   
    // Read the 'userID' cookie from this domain
    const cookieValue = getCookieval(thirdPartyCookieName);
   
    // Check if the cookie was found
    if (cookieValue !== undefined) {
      console.log(`[IFRAME] Found cookie '${thirdPartyCookieName}'. Value: '${cookieValue}'. Sending to parent.`);
   
      // Send the cookie value to the specific parent origin
      parent.postMessage({
        type: 'thirdPartyCookieData', // Identifier for the parent listener
        cookieName: thirdPartyCookieName, // Let parent know which cookie it was
        value: cookieValue
      }, parentOrigin); // SECURITY: Target the specific parent origin
   
    } else {
      console.log(`[IFRAME] Cookie '${thirdPartyCookieName}' was not found on this domain.`);
   
      // Optionally, inform the parent that the cookie wasn't found
      parent.postMessage({
        type: 'thirdPartyCookieNotFound',
        cookieName: thirdPartyCookieName
      }, parentOrigin);
    }
  });

   try {
      console.log('[IFRAME] Script execution finished setup.');
  } catch (e) {
      console.error('[IFRAME] Error during script setup or initial execution:', e);
  }
  // If automatic tracking is disabled, log a message
} else {
  console.log("Automatic tracking is disabled.");
}

     </script> 

  </head>
<body class="w3-content" style="max-width:1200px">

<!-- Sidebar/menu -->
<nav class="w3-sidebar w3-bar-block w3-white w3-collapse w3-top" style="z-index:3;width:250px" id="mySidebar">
  <div class="w3-container w3-display-container w3-padding-16">
    <i onclick="w3_close()" class="fa fa-remove w3-hide-large w3-button w3-display-topright"></i>
    <h3 class="w3-wide"><b>LOGO</b></h3>
  </div>
  <div class="w3-padding-64 w3-large w3-text-grey" style="font-weight:bold">
    <a href="#" class="w3-bar-item w3-button">Shirts</a>
    <a href="#" class="w3-bar-item w3-button">Dresses</a>
    <a onclick="myAccFunc()" href="javascript:void(0)" class="w3-button w3-block w3-white w3-left-align" id="myBtn">
      Jeans <i class="fa fa-caret-down"></i>
    </a>
    <div id="demoAcc" class="w3-bar-block w3-hide w3-padding-large w3-medium">
      <a href="#" class="w3-bar-item w3-button w3-light-grey"><i class="fa fa-caret-right w3-margin-right"></i>Skinny</a>
      <a href="#" class="w3-bar-item w3-button">Relaxed</a>
      <a href="#" class="w3-bar-item w3-button">Bootcut</a>
      <a href="#" class="w3-bar-item w3-button">Straight</a>
    </div>
    <a href="#" class="w3-bar-item w3-button">Jackets</a>
    <a href="#" class="w3-bar-item w3-button">Gymwear</a>
    <a href="#" class="w3-bar-item w3-button">Blazers</a>
    <a href="#" class="w3-bar-item w3-button">Shoes</a>
  </div>
  <a href="#footer" class="w3-bar-item w3-button w3-padding">Contact</a> 
  <a href="javascript:void(0)" class="w3-bar-item w3-button w3-padding" onclick="document.getElementById('newsletter').style.display='block'">Newsletter</a> 
  <a href="#footer"  class="w3-bar-item w3-button w3-padding">Subscribe</a>
</nav>

<!-- Top menu on small screens -->
<header class="w3-bar w3-top w3-hide-large w3-black w3-xlarge">
  <div class="w3-bar-item w3-padding-24 w3-wide">LOGO</div>
  <a href="javascript:void(0)" class="w3-bar-item w3-button w3-padding-24 w3-right" onclick="w3_open()"><i class="fa fa-bars"></i></a>

</header>

<!-- Overlay effect when opening sidebar on small screens -->
<div class="w3-overlay w3-hide-large" onclick="w3_close()" style="cursor:pointer" title="close side menu" id="myOverlay"></div>

<!-- !PAGE CONTENT! -->
<div class="w3-main" style="margin-left:250px">

  <!-- Push down content on small screens -->
  <div class="w3-hide-large" style="margin-top:83px"></div>
  
  <!-- Top header -->
  <header class="w3-container w3-xlarge">
    <p class="w3-left">Jeans</p>
    <p class="w3-right">
      <i class="fa fa-shopping-cart w3-margin-right"></i>
      <i class="fa fa-search"></i>
    </p>
  </header>

  <!-- Image header -->
  <div class="w3-display-container w3-container">
    <img src="https://www.w3schools.com/w3images/jeans.jpg" alt="Jeans" style="width:100%">
    <div class="w3-display-topleft w3-text-white" style="padding:24px 48px">
      <h1 class="w3-jumbo w3-hide-small">New arrivals</h1>
      <h1 class="w3-hide-large w3-hide-medium">New arrivals</h1>
      <h1 class="w3-hide-small">COLLECTION 2016</h1>
      <p><a href="#jeans" id="shopnow" class="w3-button w3-black w3-padding-large w3-large">SHOP NOW</a></p>
    </div>
  </div>

  <div class="w3-container w3-text-grey" id="jeans">
    <p>8 items</p>
  </div>

  <!-- Product grid -->
  <div class="w3-row w3-grayscale">
    <div class="w3-col l3 s6">
      <div class="w3-container">
        <img src="https://www.w3schools.com/w3images/jeans1.jpg" style="width:100%">
        <p>Ripped Skinny Jeans<br><b>$24.99</b></p>
      </div>
      <div class="w3-container">
        <img src="https://www.w3schools.com/w3images/jeans2.jpg" style="width:100%">
        <p>Mega Ripped Jeans<br><b>$19.99</b></p>
      </div>
    </div>

    <div class="w3-col l3 s6">
      <div class="w3-container">
        <div class="w3-display-container">
          <img src="https://www.w3schools.com/w3images/jeans2.jpg" style="width:100%">
          <span class="w3-tag w3-display-topleft">New</span>
          <div class="w3-display-middle w3-display-hover">
            <button id="buynow" class="w3-button w3-black">Buy now <i class="fa fa-shopping-cart"></i></button>
          </div>
        </div>
        <p>Mega Ripped Jeans<br><b>$19.99</b></p>
      </div>
      <div class="w3-container">
        <img src="https://www.w3schools.com/w3images/jeans3.jpg" style="width:100%">
        <p>Washed Skinny Jeans<br><b>$20.50</b></p>
      </div>
    </div>

    <div class="w3-col l3 s6">
      <div class="w3-container">
        <img src="https://www.w3schools.com/w3images/jeans3.jpg" style="width:100%">
        <p>Washed Skinny Jeans<br><b>$20.50</b></p>
      </div>
      <div class="w3-container">
        <div class="w3-display-container">
          <img src="https://www.w3schools.com/w3images/jeans4.jpg" style="width:100%">
          <span class="w3-tag w3-display-topleft">Sale</span>
          <div class="w3-display-middle w3-display-hover">
            <button class="w3-button w3-black">Buy now <i class="fa fa-shopping-cart"></i></button>
          </div>
        </div>
        <p>Vintage Skinny Jeans<br><b class="w3-text-red">$14.99</b></p>
      </div>
    </div>

    <div class="w3-col l3 s6">
      <div class="w3-container">
        <img src="https://www.w3schools.com/w3images/jeans4.jpg" style="width:100%">
        <p>Vintage Skinny Jeans<br><b>$14.99</b></p>
      </div>
      <div class="w3-container">
        <img src="https://www.w3schools.com/w3images/jeans1.jpg" style="width:100%">
        <p>Ripped Skinny Jeans<br><b>$24.99</b></p>
      </div>
    </div>
  </div>

  <!-- Subscribe section -->
  <div class="w3-container w3-black w3-padding-32">
    <h1>Subscribe</h1>
    <p>To get special offers and VIP treatment:</p>
    <p><input class="w3-input w3-border" type="text" placeholder="Enter e-mail" style="width:100%"></p>
    <button type="button" class="w3-button w3-red w3-margin-bottom">Subscribe</button>
  </div>
  
  <!-- Footer -->
  <footer class="w3-padding-64 w3-light-grey w3-small w3-center" id="footer">
    <div class="w3-row-padding">
      <div class="w3-col s4">
        <h4>Contact</h4>
        <p>Questions? Go ahead.</p>
        <form action="/action_page.php" target="_blank">
          <p><input class="w3-input w3-border" type="text" placeholder="Name" name="Name" required></p>
          <p><input class="w3-input w3-border" type="text" placeholder="Email" name="Email" required></p>
          <p><input class="w3-input w3-border" type="text" placeholder="Subject" name="Subject" required></p>
          <p><input class="w3-input w3-border" type="text" placeholder="Message" name="Message" required></p>
          <button type="submit" class="w3-button w3-block w3-black">Send</button>
        </form>
      </div>

      <div class="w3-col s4">
        <h4>About</h4>
        <p><a href="#">About us</a></p>
        <p><a href="#">We're hiring</a></p>
        <p><a href="#">Support</a></p>
        <p><a href="#">Find store</a></p>
        <p><a href="testpage.html">test page</a></p>
         <p><a href="testpageone.html">test page one</a></p>
        <p><a href="testpagetwo.html?utm_source=google&utm_medium=cpc&utm_campaign=spring_sale&utm_term=test_term&utm_content=test_content">test page two</a></p>
        <p><a href="testpagethree.html">test page three</a></p>
        <p><a href="https://www.test.anotherdomain.com">Help</a></p>
        <p><a href="https://www.youtube.com/watch?v=EerdGm-ehJQ">play video</a></p>
      </div>

      <div class="w3-col s4 w3-justify">
        <h4>Store</h4>
        <p><i class="fa fa-fw fa-map-marker"></i> Company Name</p>
        <p><i class="fa fa-fw fa-phone"></i> 0044123123</p>
        <p><i class="fa fa-fw fa-envelope"></i> ex@mail.com</p>
        <h4>We accept</h4>
        <p><i class="fa fa-fw fa-cc-amex"></i> Amex</p>
        <p><i class="fa fa-fw fa-credit-card"></i> Credit Card</p>
        <br>
        <a href="https://clickstromtest.vercel.app/">https://clickstromtest.vercel.app</a> <br></br>
        <a href = "https://www.facebook.com/" class="fa fa-facebook-official w3-hover-opacity w3-large"></a>
        <i class="fa fa-instagram w3-hover-opacity w3-large"></i>
        <i class="fa fa-snapchat w3-hover-opacity w3-large"></i>
        <i class="fa fa-pinterest-p w3-hover-opacity w3-large"></i>
        <i class="fa fa-twitter w3-hover-opacity w3-large"></i>
        <i class="fa fa-linkedin w3-hover-opacity w3-large"></i>
        <iframe width="420" height="315" src="https://www.youtube.com/embed/tgbNymZ7vqY"> </iframe>
       <!-- <iframe width="420" height="315" src="https://player.vimeo.com/video/76979871" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>  -->
        
      </div>
    </div>

    <!-- OneTrust Cookies Settings button start -->
<button id="ot-sdk-btn" class="ot-sdk-show-settings">Cookie Settings</button>
<!-- OneTrust Cookies Settings button end -->
  </footer>

  <div class="w3-black w3-center w3-padding-24">Made with <a href="https://www.w3schools.com/spaces" title="W3.CSS" target="_blank" class="w3-hover-opacity">W3Schools Spaces</a></div>

  <!-- End page content -->
</div>

<!-- Newsletter Modal -->
<div id="newsletter" class="w3-modal">
  <div class="w3-modal-content w3-animate-zoom" style="padding:32px">
    <div class="w3-container w3-white w3-center">
      <i onclick="document.getElementById('newsletter').style.display='none'" class="fa fa-remove w3-right w3-button w3-transparent w3-xxlarge"></i>
      <h2 class="w3-wide">NEWSLETTER</h2>
      <p>Join our mailing list to receive updates on new arrivals and special offers.</p>
      <p><input class="w3-input w3-border" type="text" placeholder="Enter e-mail"></p>
      <button type="button" class="w3-button w3-padding-large w3-red w3-margin-bottom" onclick="document.getElementById('newsletter').style.display='none'">Subscribe</button>
    </div>
  </div>
</div>

<script>
// Accordion 
function myAccFunc() {
  var x = document.getElementById("demoAcc");
  if (x.className.indexOf("w3-show") == -1) {
    x.className += " w3-show";
  } else {
    x.className = x.className.replace(" w3-show", "");
  }
}

// Click on the "Jeans" link on page load to open the accordion for demo purposes
document.getElementById("myBtn").click();


// Open and close sidebar
function w3_open() {
  document.getElementById("mySidebar").style.display = "block";
  document.getElementById("myOverlay").style.display = "block";
}
 
function w3_close() {
  document.getElementById("mySidebar").style.display = "none";
  document.getElementById("myOverlay").style.display = "none";
}

</script>
 
</body>
</html>
